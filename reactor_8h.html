<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: core/reactor.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">reactor-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">reactor.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &quot;<a class="el" href="pqueue_8h_source.html">pqueue.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tag_8h_source.html">tag.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="platform_8h_source.html">platform.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trace_8h_source.html">trace.h</a>&quot;</code><br />
</div>
<p><a href="reactor_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__token__t.html">lf_token_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoken__present__t.html">token_present_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreaction__t.html">reaction_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__t.html">event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrigger__t.html">trigger_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a71bcdce172253c19667053352afdf496"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a71bcdce172253c19667053352afdf496">CONSTRUCTOR</a>(classname)&#160;&#160;&#160;(new_ ## classname)</td></tr>
<tr class="separator:a71bcdce172253c19667053352afdf496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac783147cb265dcb8f2920def647037e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ac783147cb265dcb8f2920def647037e0">SELF_STRUCT_T</a>(classname)&#160;&#160;&#160;(classname ## _self_t)</td></tr>
<tr class="separator:ac783147cb265dcb8f2920def647037e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88789cadebf89616a6c179b429f64a72"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a88789cadebf89616a6c179b429f64a72">INITIAL_EVENT_QUEUE_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a88789cadebf89616a6c179b429f64a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90a33a3249c67258eed6ac36793bd39"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ab90a33a3249c67258eed6ac36793bd39">INITIAL_REACT_QUEUE_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ab90a33a3249c67258eed6ac36793bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f7e281be573bc680ed652ad54f5386"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#af5f7e281be573bc680ed652ad54f5386">_LF_SET</a>(out,  val)</td></tr>
<tr class="separator:af5f7e281be573bc680ed652ad54f5386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4001d12854ff4675f7d119dfb0b952"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a8a4001d12854ff4675f7d119dfb0b952">_LF_SET_ARRAY</a>(out,  val,  element_size,  length)</td></tr>
<tr class="separator:a8a4001d12854ff4675f7d119dfb0b952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d69be73768b3d144a524fa87f0d069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ae6d69be73768b3d144a524fa87f0d069">_LF_SET_NEW</a>(out)</td></tr>
<tr class="separator:ae6d69be73768b3d144a524fa87f0d069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c4d124085ac4279bac7158ad144218"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a64c4d124085ac4279bac7158ad144218">_LF_SET_NEW_ARRAY</a>(out,  len)</td></tr>
<tr class="separator:a64c4d124085ac4279bac7158ad144218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26960b6a12ebe9eff3f276c2b07096ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a26960b6a12ebe9eff3f276c2b07096ab">_LF_SET_PRESENT</a>(out)</td></tr>
<tr class="separator:a26960b6a12ebe9eff3f276c2b07096ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f45a70cbab4e36efdc9efdcf37a7bb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a5f45a70cbab4e36efdc9efdcf37a7bb9">_LF_SET_TOKEN</a>(out,  newtoken)</td></tr>
<tr class="separator:a5f45a70cbab4e36efdc9efdcf37a7bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aab573132838d44997ee99002d3e6d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a4aab573132838d44997ee99002d3e6d0">DEADLINE</a>(index)&#160;&#160;&#160;(index &amp; 0x7FFFFFFFFFFF0000)</td></tr>
<tr class="separator:a4aab573132838d44997ee99002d3e6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d86a8b9f2059af4b3f9f1862fdb2145"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a6d86a8b9f2059af4b3f9f1862fdb2145">LEVEL</a>(index)&#160;&#160;&#160;(index &amp; 0xFFFF)</td></tr>
<tr class="separator:a6d86a8b9f2059af4b3f9f1862fdb2145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9931d7524c88e07743af6535b20761"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#aff9931d7524c88e07743af6535b20761">MAX</a>(X,  Y)&#160;&#160;&#160;(((X) &gt; (Y)) ? (X) : (Y))</td></tr>
<tr class="separator:aff9931d7524c88e07743af6535b20761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f3678bf5eae3684fc497130b946eae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ad2f3678bf5eae3684fc497130b946eae">MIN</a>(X,  Y)&#160;&#160;&#160;(((X) &lt; (Y)) ? (X) : (Y))</td></tr>
<tr class="separator:ad2f3678bf5eae3684fc497130b946eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ad7b5ea629e5f900ed750be8b1a357"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a05ad7b5ea629e5f900ed750be8b1a357">OVERLAPPING</a>(chain1,  chain2)&#160;&#160;&#160;((chain1 &amp; chain2) != 0)</td></tr>
<tr class="separator:a05ad7b5ea629e5f900ed750be8b1a357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b6cff12498f2db056084f86154d9a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a20b6cff12498f2db056084f86154d9a4">OK_TO_FREE</a>&#160;&#160;&#160;<a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16aad3aafaeae035f5d1c986b0b59e77458">token_and_value</a></td></tr>
<tr class="separator:a20b6cff12498f2db056084f86154d9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3fa7784c89589b49764048e9909d0e07"><td class="memItemLeft" align="right" valign="top">typedef unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a3fa7784c89589b49764048e9909d0e07">ushort</a></td></tr>
<tr class="separator:a3fa7784c89589b49764048e9909d0e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad7d32f3a1ddabdc2933223ca6ce2ea"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a></td></tr>
<tr class="separator:a5ad7d32f3a1ddabdc2933223ca6ce2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4505c08c065b48840a30eedd9845cce2"><td class="memItemLeft" align="right" valign="top">typedef char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a4505c08c065b48840a30eedd9845cce2">string</a></td></tr>
<tr class="separator:a4505c08c065b48840a30eedd9845cce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4448d06be794d3f5412d0edb412dc00e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="pqueue_8h.html#ad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a4448d06be794d3f5412d0edb412dc00e">index_t</a></td></tr>
<tr class="separator:a4448d06be794d3f5412d0edb412dc00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149e5fee1c1841bcc96c72f200601d90"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a149e5fee1c1841bcc96c72f200601d90">reaction_function_t</a>) (void *)</td></tr>
<tr class="separator:a149e5fee1c1841bcc96c72f200601d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98c19a4a03c495fdd3044c206e99afc"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtrigger__t.html">trigger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ae98c19a4a03c495fdd3044c206e99afc">trigger_t</a></td></tr>
<tr class="separator:ae98c19a4a03c495fdd3044c206e99afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e404c4c1bd798a54501d0e1d640f9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlf__token__t.html">lf_token_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a973e404c4c1bd798a54501d0e1d640f9">lf_token_t</a></td></tr>
<tr class="separator:a973e404c4c1bd798a54501d0e1d640f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c506d193748554de2ff32e5f7cee41e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtoken__present__t.html">token_present_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a2c506d193748554de2ff32e5f7cee41e">token_present_t</a></td></tr>
<tr class="separator:a2c506d193748554de2ff32e5f7cee41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0f71b6c8e0c54c65cbfaa154b40694"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structreaction__t.html">reaction_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a1f0f71b6c8e0c54c65cbfaa154b40694">reaction_t</a></td></tr>
<tr class="separator:a1f0f71b6c8e0c54c65cbfaa154b40694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f5f6b9c6023baebf9c49c328b639a1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structevent__t.html">event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a59f5f6b9c6023baebf9c49c328b639a1">event_t</a></td></tr>
<tr class="separator:a59f5f6b9c6023baebf9c49c328b639a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0183c0b43037a172a1cd9aa6ed6b3822"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a0183c0b43037a172a1cd9aa6ed6b3822">lf_spacing_policy_t</a> { <a class="el" href="reactor_8h.html#a0183c0b43037a172a1cd9aa6ed6b3822a893b1cf0de04eaf44a009fecabd16b90">defer</a>
, <a class="el" href="reactor_8h.html#a0183c0b43037a172a1cd9aa6ed6b3822a1e34755950041e469ca91ff2b7d1c019">drop</a>
, <a class="el" href="reactor_8h.html#a0183c0b43037a172a1cd9aa6ed6b3822a8a4df390c6f816287b90cb2b33ab4323">replace</a>
 }</td></tr>
<tr class="separator:a0183c0b43037a172a1cd9aa6ed6b3822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174f339edecd4463df25e673366a2b16"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16">ok_to_free_t</a> { <a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16a8fe4a05f1addc1b9a4aae17d7b166646">no</a> =0
, <a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16aad3aafaeae035f5d1c986b0b59e77458">token_and_value</a>
, <a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16aea2a62f409bdd1a145204606c8efb75b">token_only</a>
 }</td></tr>
<tr class="separator:a174f339edecd4463df25e673366a2b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759ba374f75ea0025b9af1bb35f14d7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a> { <a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7ea1a8fae68a24a59c5629c241401fabb08">absent</a> = false
, <a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7eaaeb73d7cb56b19bff3d9f80426ed3267">present</a> = true
, <a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7ea5b9f6d065e6e98483b3d3ed01f4f6cbe">unknown</a>
 }</td></tr>
<tr class="separator:a759ba374f75ea0025b9af1bb35f14d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8b4f2e4e87e43670217c0c53099ae2f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a8b4f2e4e87e43670217c0c53099ae2f5">get_start_time</a> ()</td></tr>
<tr class="separator:a8b4f2e4e87e43670217c0c53099ae2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54be08fbc7990c2d8082a31cbbf6e019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a54be08fbc7990c2d8082a31cbbf6e019">get_stp_offset</a> ()</td></tr>
<tr class="separator:a54be08fbc7990c2d8082a31cbbf6e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a5bf324229d35fb88541a04449c95b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a75a5bf324229d35fb88541a04449c95b">set_stp_offset</a> (<a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> offset)</td></tr>
<tr class="separator:a75a5bf324229d35fb88541a04449c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96dc6cbe1d3365e52aad6aecbf036d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ad96dc6cbe1d3365e52aad6aecbf036d8">print_snapshot</a> ()</td></tr>
<tr class="separator:ad96dc6cbe1d3365e52aad6aecbf036d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af629769c213699f0e4c9360811ee7251"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#af629769c213699f0e4c9360811ee7251">request_stop</a> ()</td></tr>
<tr class="separator:af629769c213699f0e4c9360811ee7251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbba6d4986cc6d46b07d53d3752270f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#aedbba6d4986cc6d46b07d53d3752270f">__set_default_command_line_options</a> ()</td></tr>
<tr class="separator:aedbba6d4986cc6d46b07d53d3752270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aacf433fcf349ffa1b163962eb3681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#af8aacf433fcf349ffa1b163962eb3681">__start_time_step</a> ()</td></tr>
<tr class="separator:af8aacf433fcf349ffa1b163962eb3681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868e02a04eabb4ffed63f6141f5f64a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a868e02a04eabb4ffed63f6141f5f64a2">__initialize_trigger_objects</a> ()</td></tr>
<tr class="separator:a868e02a04eabb4ffed63f6141f5f64a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1825238bcb81ecc6aeeb6dd42d308089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a1825238bcb81ecc6aeeb6dd42d308089">__pop_events</a> ()</td></tr>
<tr class="separator:a1825238bcb81ecc6aeeb6dd42d308089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b914dafd583948c817b0ae6ce739b6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a1b914dafd583948c817b0ae6ce739b6d">__schedule</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> delay, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a1b914dafd583948c817b0ae6ce739b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c5c84c6f22c1bdf98af8b1a55a9f4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ae3c5c84c6f22c1bdf98af8b1a55a9f4b">__initialize_timers</a> ()</td></tr>
<tr class="separator:ae3c5c84c6f22c1bdf98af8b1a55a9f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d807ba211ee2edb588750d4553090c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a1d807ba211ee2edb588750d4553090c1">__trigger_startup_reactions</a> ()</td></tr>
<tr class="separator:a1d807ba211ee2edb588750d4553090c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114c79dc673219d5df3b794552ca88d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a114c79dc673219d5df3b794552ca88d7">terminate_execution</a> ()</td></tr>
<tr class="separator:a114c79dc673219d5df3b794552ca88d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea1110b1a18ccf10931bf5f9adaf299"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a9ea1110b1a18ccf10931bf5f9adaf299">__trigger_shutdown_reactions</a> ()</td></tr>
<tr class="separator:a9ea1110b1a18ccf10931bf5f9adaf299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3e914b48f5f90533eecbf63acdf8d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a0b3e914b48f5f90533eecbf63acdf8d9">create_token</a> (size_t element_size)</td></tr>
<tr class="separator:a0b3e914b48f5f90533eecbf63acdf8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa715873b79dee5b9f50daa2fef88cf34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#aa715873b79dee5b9f50daa2fef88cf34">_lf_schedule_int</a> (void *action, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> extra_delay, int value)</td></tr>
<tr class="separator:aa715873b79dee5b9f50daa2fef88cf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa7db644ec69c067d3d6aadd2da9d81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#aeaa7db644ec69c067d3d6aadd2da9d81">_lf_get_new_event</a> ()</td></tr>
<tr class="separator:aeaa7db644ec69c067d3d6aadd2da9d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662cfd5714e5930f5e1c880f13deba6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a662cfd5714e5930f5e1c880f13deba6d">_lf_recycle_event</a> (<a class="el" href="structevent__t.html">event_t</a> *e)</td></tr>
<tr class="separator:a662cfd5714e5930f5e1c880f13deba6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f3a3c4613102e28fc0105408731c5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#af1f3a3c4613102e28fc0105408731c5e">_lf_schedule_at_tag</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:af1f3a3c4613102e28fc0105408731c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46845578328233d51b6bfb55e8724ee1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a46845578328233d51b6bfb55e8724ee1">_lf_create_dummy_event</a> (<a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> time, <a class="el" href="structevent__t.html">event_t</a> *<a class="el" href="reactor_8c.html#a4311a28891c362d4d0dd4f748beba33b">next</a>, unsigned int offset)</td></tr>
<tr class="separator:a46845578328233d51b6bfb55e8724ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369700b5e0906335f3d304a67eec5f29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a369700b5e0906335f3d304a67eec5f29">_lf_schedule_token</a> (void *action, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> extra_delay, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a369700b5e0906335f3d304a67eec5f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5591f2a5684d3b9ef713668e1937be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a5e5591f2a5684d3b9ef713668e1937be">_lf_schedule_value</a> (void *action, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> extra_delay, void *value, size_t length)</td></tr>
<tr class="separator:a5e5591f2a5684d3b9ef713668e1937be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e25ab993a3fe9e402534cc073f0e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a340e25ab993a3fe9e402534cc073f0e8">_lf_schedule_copy</a> (void *action, <a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> offset, void *value, size_t length)</td></tr>
<tr class="separator:a340e25ab993a3fe9e402534cc073f0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ec02f52c1a7db4c7bdbc2871eae636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a60ec02f52c1a7db4c7bdbc2871eae636">_lf_fd_send_stop_request_to_rti</a> ()</td></tr>
<tr class="separator:a60ec02f52c1a7db4c7bdbc2871eae636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadead0c4f54963b062503cf6cb7ace7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#abadead0c4f54963b062503cf6cb7ace7">_lf_advance_logical_time</a> (<a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> next_time)</td></tr>
<tr class="separator:abadead0c4f54963b062503cf6cb7ace7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46a83ed702e2c83d42625a8c78a9f50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#aa46a83ed702e2c83d42625a8c78a9f50">_lf_notify_workers</a> ()</td></tr>
<tr class="separator:aa46a83ed702e2c83d42625a8c78a9f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab461661c6c9757862959540fe57e3554"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#ab461661c6c9757862959540fe57e3554">_lf_is_blocked_by_executing_reaction</a> ()</td></tr>
<tr class="separator:ab461661c6c9757862959540fe57e3554"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a39f588e1df453139dbb9a4157dda2027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#a39f588e1df453139dbb9a4157dda2027">_lf_global_time_STP_offset</a></td></tr>
<tr class="separator:a39f588e1df453139dbb9a4157dda2027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74a2782bda0d66298d22d637ad964b5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html#af74a2782bda0d66298d22d637ad964b5">_lf_number_of_threads</a></td></tr>
<tr class="separator:af74a2782bda0d66298d22d637ad964b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span style="display: none;">.nosp@m.</span>erke<span style="display: none;">.nosp@m.</span>ley.e<span style="display: none;">.nosp@m.</span>du</a>) </dd>
<dd>
Marten Lohstroh (<a href="#" onclick="location.href='mai'+'lto:'+'mar'+'te'+'n@b'+'er'+'kel'+'ey'+'.ed'+'u'; return false;">marte<span style="display: none;">.nosp@m.</span>n@be<span style="display: none;">.nosp@m.</span>rkele<span style="display: none;">.nosp@m.</span>y.ed<span style="display: none;">.nosp@m.</span>u</a>) </dd>
<dd>
Chris Gill (<a href="#" onclick="location.href='mai'+'lto:'+'cdg'+'il'+'l@w'+'us'+'tl.'+'ed'+'u'; return false;">cdgil<span style="display: none;">.nosp@m.</span>l@wu<span style="display: none;">.nosp@m.</span>stl.e<span style="display: none;">.nosp@m.</span>du</a>) </dd>
<dd>
Mehrdad Niknami (<a href="#" onclick="location.href='mai'+'lto:'+'mni'+'kn'+'ami'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">mnikn<span style="display: none;">.nosp@m.</span>ami@<span style="display: none;">.nosp@m.</span>berke<span style="display: none;">.nosp@m.</span>ley.<span style="display: none;">.nosp@m.</span>edu</a>)</dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p >Copyright (c) 2019, The University of California at Berkeley.</p>
<p >Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p >THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p >Header file for the infrastructure for the C target of Lingua Franca. This file contains header information used by both the threaded and non-threaded versions of the C runtime. A generated C program will have either #include <a class="el" href="reactor_8c.html">reactor.c</a> or #include <a class="el" href="reactor__threaded_8c.html">reactor_threaded.c</a>. Those two files #include this header file.</p>
<p >This header file defines the functions and macros that programmers use in the body of reactions for reading and writing inputs and outputs and scheduling future events. The LF compiler does not parse that C code. This fact strongly affects the design.</p>
<p >The intent of the C target for Lingua Franca not to provide a safe programming environment (The C++ and TypeScript targets are better choices for that), but rather to find the lowest possible overhead implementation of Lingua Franca. The API herein can easily be misused, leading to memory leaks, nondeterminism, or program crashes. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af5f7e281be573bc680ed652ad54f5386" name="af5f7e281be573bc680ed652ad54f5386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f7e281be573bc680ed652ad54f5386">&#9670;&nbsp;</a></span>_LF_SET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_SET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">    out-&gt;value = val; \</div>
<div class="line">    out-&gt;is_present = <span class="keyword">true</span>; \</div>
<div class="line">} <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment --><p >Set the specified output (or input of a contained reactor) to the specified value.</p>
<p >This version is used for primitive types such as int, double, etc. as well as the built-in types bool and string. The value is copied and therefore the variable carrying the value can be subsequently modified without changing the output. This can also be used for structs with a type defined by a typedef so that the type designating string does not end in '*'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name) or input of a contained reactor in form input_name.port_name. </td></tr>
    <tr><td class="paramname">value</td><td>The value to insert into the self struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a4001d12854ff4675f7d119dfb0b952" name="a8a4001d12854ff4675f7d119dfb0b952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4001d12854ff4675f7d119dfb0b952">&#9670;&nbsp;</a></span>_LF_SET_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_SET_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">val, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">length&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">    out-&gt;is_present = <span class="keyword">true</span>; \</div>
<div class="line">    lf_token_t* token = <a class="code hl_function" href="reactor__common_8c.html#a2f461eb2991ded742049ab90cc61c404">__initialize_token_with_value</a>(out-&gt;token, val, length); \</div>
<div class="line">    token-&gt;ref_count = out-&gt;num_destinations; \</div>
<div class="line">    out-&gt;token = token; \</div>
<div class="line">    out-&gt;value = token-&gt;value; \</div>
<div class="line">} <span class="keywordflow">while</span>(0)</div>
<div class="ttc" id="areactor__common_8c_html_a2f461eb2991ded742049ab90cc61c404"><div class="ttname"><a href="reactor__common_8c.html#a2f461eb2991ded742049ab90cc61c404">__initialize_token_with_value</a></div><div class="ttdeci">lf_token_t * __initialize_token_with_value(lf_token_t *token, void *value, size_t length)</div><div class="ttdef"><b>Definition:</b> reactor_common.c:523</div></div>
</div><!-- fragment --><p >Version of set for output types given as 'type[]' where you want to send a previously dynamically allocated array.</p>
<p >The deallocation is delegated to downstream reactors, which automatically deallocate when the reference count drops to zero. It also sets the corresponding _is_present variable in the self struct to true (which causes the object message to be sent). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
    <tr><td class="paramname">val</td><td>The array to send (a pointer to the first element). </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlf__token__t.html">lf_token_t</a> </dd></dl>

</div>
</div>
<a id="ae6d69be73768b3d144a524fa87f0d069" name="ae6d69be73768b3d144a524fa87f0d069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d69be73768b3d144a524fa87f0d069">&#9670;&nbsp;</a></span>_LF_SET_NEW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_SET_NEW</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">    out-&gt;is_present = <span class="keyword">true</span>; \</div>
<div class="line">    lf_token_t* token = <a class="code hl_function" href="reactor__common_8c.html#a38aec20ad67725b0314d4f077c619d92">__set_new_array_impl</a>(out-&gt;token, 1, out-&gt;num_destinations); \</div>
<div class="line">    out-&gt;value = token-&gt;value; \</div>
<div class="line">    out-&gt;token = token; \</div>
<div class="line">} <span class="keywordflow">while</span>(0)</div>
<div class="ttc" id="areactor__common_8c_html_a38aec20ad67725b0314d4f077c619d92"><div class="ttname"><a href="reactor__common_8c.html#a38aec20ad67725b0314d4f077c619d92">__set_new_array_impl</a></div><div class="ttdeci">lf_token_t * __set_new_array_impl(lf_token_t *token, size_t length, int num_destinations)</div><div class="ttdef"><b>Definition:</b> reactor_common.c:1428</div></div>
</div><!-- fragment --><p >Version of set() for output types given as 'type*' that allocates a new object of the type of the specified output port.</p>
<p >This macro dynamically allocates enough memory to contain one instance of the output datatype and sets the variable named by the argument to point to the newly allocated memory. The user code can then populate it with whatever value it wishes to send.</p>
<p >This macro also sets the corresponding _is_present variable in the self struct to true (which causes the object message to be sent), </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64c4d124085ac4279bac7158ad144218" name="a64c4d124085ac4279bac7158ad144218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c4d124085ac4279bac7158ad144218">&#9670;&nbsp;</a></span>_LF_SET_NEW_ARRAY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_SET_NEW_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">    out-&gt;is_present = <span class="keyword">true</span>; \</div>
<div class="line">    lf_token_t* token = <a class="code hl_function" href="reactor__common_8c.html#a38aec20ad67725b0314d4f077c619d92">__set_new_array_impl</a>(out-&gt;token, len, out-&gt;num_destinations); \</div>
<div class="line">    out-&gt;value = token-&gt;value; \</div>
<div class="line">    out-&gt;token = token; \</div>
<div class="line">    out-&gt;length = len; \</div>
<div class="line">} <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment --><p >Version of set() for output types given as 'type[]'.</p>
<p >This allocates a new array of the specified length, sets the corresponding _is_present variable in the self struct to true (which causes the array message to be sent), and sets the variable given by the first argument to point to the new array so that the user code can populate the array. The freeing of the dynamically allocated array will be handled automatically when the last downstream reader of the message has finished. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array to be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26960b6a12ebe9eff3f276c2b07096ab" name="a26960b6a12ebe9eff3f276c2b07096ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26960b6a12ebe9eff3f276c2b07096ab">&#9670;&nbsp;</a></span>_LF_SET_PRESENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_SET_PRESENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">    out-&gt;is_present = <span class="keyword">true</span>; \</div>
<div class="line">} <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment --><p >Version of set() for output types given as 'type[number]'.</p>
<p >This sets the _is_present variable corresponding to the specified output to true (which causes the array message to be sent). The values in the output are normally written directly to the array or struct before or after this is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f45a70cbab4e36efdc9efdcf37a7bb9" name="a5f45a70cbab4e36efdc9efdcf37a7bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f45a70cbab4e36efdc9efdcf37a7bb9">&#9670;&nbsp;</a></span>_LF_SET_TOKEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_SET_TOKEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">newtoken&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> { \</div>
<div class="line">    out-&gt;is_present = <span class="keyword">true</span>; \</div>
<div class="line">    out-&gt;value = newtoken-&gt;value; \</div>
<div class="line">    out-&gt;token = newtoken; \</div>
<div class="line">    newtoken-&gt;ref_count += out-&gt;num_destinations; \</div>
<div class="line">    out-&gt;is_present = <span class="keyword">true</span>; \</div>
<div class="line">    out-&gt;length = newtoken-&gt;length; \</div>
<div class="line">} <span class="keywordflow">while</span>(0)</div>
</div><!-- fragment --><p >Version of set() for output types given as 'type*' or 'type[]' where you want to forward an input or action without copying it.</p>
<p >The deallocation of memory is delegated to downstream reactors, which automatically deallocate when the reference count drops to zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
    <tr><td class="paramname">token</td><td>A pointer to token obtained from an input or action. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71bcdce172253c19667053352afdf496" name="a71bcdce172253c19667053352afdf496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bcdce172253c19667053352afdf496">&#9670;&nbsp;</a></span>CONSTRUCTOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONSTRUCTOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">classname</td><td>)</td>
          <td>&#160;&#160;&#160;(new_ ## classname)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aab573132838d44997ee99002d3e6d0" name="a4aab573132838d44997ee99002d3e6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aab573132838d44997ee99002d3e6d0">&#9670;&nbsp;</a></span>DEADLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEADLINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index</td><td>)</td>
          <td>&#160;&#160;&#160;(index &amp; 0x7FFFFFFFFFFF0000)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Macro for extracting the deadline from the index of a reaction. The reaction queue is sorted according to this index, and the use of the deadline here results in an earliest deadline first (EDF) scheduling poicy. </p>

</div>
</div>
<a id="a88789cadebf89616a6c179b429f64a72" name="a88789cadebf89616a6c179b429f64a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88789cadebf89616a6c179b429f64a72">&#9670;&nbsp;</a></span>INITIAL_EVENT_QUEUE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INITIAL_EVENT_QUEUE_SIZE&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab90a33a3249c67258eed6ac36793bd39" name="ab90a33a3249c67258eed6ac36793bd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90a33a3249c67258eed6ac36793bd39">&#9670;&nbsp;</a></span>INITIAL_REACT_QUEUE_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INITIAL_REACT_QUEUE_SIZE&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d86a8b9f2059af4b3f9f1862fdb2145" name="a6d86a8b9f2059af4b3f9f1862fdb2145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d86a8b9f2059af4b3f9f1862fdb2145">&#9670;&nbsp;</a></span>LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LEVEL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index</td><td>)</td>
          <td>&#160;&#160;&#160;(index &amp; 0xFFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Macro for extracting the level from the index of a reaction. A reaction that has no upstream reactions has level 0. Other reactions have a level that is the length of the longest upstream chain to a reaction with level 0 (inclusive). This is used, along with the deadline, to sort reactions in the reaction queue. It ensures that reactions that are upstream in the dependence graph execute before reactions that are downstream. </p>

</div>
</div>
<a id="aff9931d7524c88e07743af6535b20761" name="aff9931d7524c88e07743af6535b20761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9931d7524c88e07743af6535b20761">&#9670;&nbsp;</a></span>MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((X) &gt; (Y)) ? (X) : (Y))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility for finding the maximum of two values. </p>

</div>
</div>
<a id="ad2f3678bf5eae3684fc497130b946eae" name="ad2f3678bf5eae3684fc497130b946eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f3678bf5eae3684fc497130b946eae">&#9670;&nbsp;</a></span>MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">X, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((X) &lt; (Y)) ? (X) : (Y))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Utility for finding the minimum of two values. </p>

</div>
</div>
<a id="a20b6cff12498f2db056084f86154d9a4" name="a20b6cff12498f2db056084f86154d9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b6cff12498f2db056084f86154d9a4">&#9670;&nbsp;</a></span>OK_TO_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OK_TO_FREE&#160;&#160;&#160;<a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16aad3aafaeae035f5d1c986b0b59e77458">token_and_value</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The flag OK_TO_FREE is used to indicate whether the void* in toke_t should be freed or not. </p>

</div>
</div>
<a id="a05ad7b5ea629e5f900ed750be8b1a357" name="a05ad7b5ea629e5f900ed750be8b1a357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ad7b5ea629e5f900ed750be8b1a357">&#9670;&nbsp;</a></span>OVERLAPPING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OVERLAPPING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chain1, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">chain2&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((chain1 &amp; chain2) != 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Macro for determining whether two reactions are in the same chain (one depends on the other). This is conservative. If it returns false, then they are surely not in the same chain, but if it returns true, they may be in the same chain. This is in <a class="el" href="reactor__threaded_8c.html">reactor_threaded.c</a> to execute reactions in parallel on multiple cores even if their levels are different. </p>

</div>
</div>
<a id="ac783147cb265dcb8f2920def647037e0" name="ac783147cb265dcb8f2920def647037e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac783147cb265dcb8f2920def647037e0">&#9670;&nbsp;</a></span>SELF_STRUCT_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SELF_STRUCT_T</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">classname</td><td>)</td>
          <td>&#160;&#160;&#160;(classname ## _self_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a59f5f6b9c6023baebf9c49c328b639a1" name="a59f5f6b9c6023baebf9c49c328b639a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f5f6b9c6023baebf9c49c328b639a1">&#9670;&nbsp;</a></span>event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structevent__t.html">event_t</a> <a class="el" href="structevent__t.html">event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Typedef for <a class="el" href="structevent__t.html">event_t</a> struct, used for storing activation records. </p>

</div>
</div>
<a id="a5ad7d32f3a1ddabdc2933223ca6ce2ea" name="a5ad7d32f3a1ddabdc2933223ca6ce2ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad7d32f3a1ddabdc2933223ca6ce2ea">&#9670;&nbsp;</a></span>handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Handles for scheduled triggers. These handles are returned by <a class="el" href="ctarget_8c.html#a961a0ed618d8dbb43f9f3b2bf3541af4">schedule()</a> functions. The intent is that the handle can be used to cancel a future scheduled event, but this is not implemented yet. </p>

</div>
</div>
<a id="a4448d06be794d3f5412d0edb412dc00e" name="a4448d06be794d3f5412d0edb412dc00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4448d06be794d3f5412d0edb412dc00e">&#9670;&nbsp;</a></span>index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="pqueue_8h.html#ad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> <a class="el" href="reactor_8h.html#a4448d06be794d3f5412d0edb412dc00e">index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Topological order index for reactions. </p>

</div>
</div>
<a id="a973e404c4c1bd798a54501d0e1d640f9" name="a973e404c4c1bd798a54501d0e1d640f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973e404c4c1bd798a54501d0e1d640f9">&#9670;&nbsp;</a></span>lf_token_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlf__token__t.html">lf_token_t</a> <a class="el" href="structlf__token__t.html">lf_token_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Token type for dynamically allocated arrays and structs sent as messages.</p>
<p >In the C LF target, a type for an output that ends in '*' is treated specially. The value carried by the output is assumed to be in dynamically allocated memory, and, using reference counting, after the last downstream reader of the value has finished, the memory will be freed. To prevent this freeing from occurring, the output type can be specified using the syntax {= type* =}; this will not be treated as dynamically allocated memory. Alternatively, the programmer can give a typedef in the preamble that masks the trailing *.</p>
<p >This struct is the wrapper around the dynamically allocated memory that carries the message. The message can be an array of values, where the size of each value is element_size (in bytes). If it is not an array, the length == 1. </p>

</div>
</div>
<a id="a149e5fee1c1841bcc96c72f200601d90" name="a149e5fee1c1841bcc96c72f200601d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149e5fee1c1841bcc96c72f200601d90">&#9670;&nbsp;</a></span>reaction_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* reaction_function_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reaction function type. The argument passed to one of these reaction functions is a pointer to the self struct for the reactor. </p>

</div>
</div>
<a id="a1f0f71b6c8e0c54c65cbfaa154b40694" name="a1f0f71b6c8e0c54c65cbfaa154b40694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0f71b6c8e0c54c65cbfaa154b40694">&#9670;&nbsp;</a></span>reaction_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structreaction__t.html">reaction_t</a> <a class="el" href="structreaction__t.html">reaction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Reaction activation record to push onto the reaction queue. Some of the information in this struct is common among all instances of the reactor, and some is specific to each particular instance. These are marked below COMMON or INSTANCE accordingly. The COMMON information is set in the constructor. The fields marked RUNTIME have values that change during execution. Instances of this struct are put onto the reaction queue (reaction_q). </p>

</div>
</div>
<a id="a4505c08c065b48840a30eedd9845cce2" name="a4505c08c065b48840a30eedd9845cce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4505c08c065b48840a30eedd9845cce2">&#9670;&nbsp;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char* <a class="el" href="reactor_8h.html#a4505c08c065b48840a30eedd9845cce2">string</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >String type so that we don't have to use {= char* =}. Use this for strings that are not dynamically allocated. For dynamically allocated strings that have to be freed after being consumed downstream, use type char*. </p>

</div>
</div>
<a id="a2c506d193748554de2ff32e5f7cee41e" name="a2c506d193748554de2ff32e5f7cee41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c506d193748554de2ff32e5f7cee41e">&#9670;&nbsp;</a></span>token_present_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtoken__present__t.html">token_present_t</a> <a class="el" href="structtoken__present__t.html">token_present_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A struct with a pointer to a <a class="el" href="structlf__token__t.html">lf_token_t</a> and an _is_present variable for use to initialize actions in start_time_step(). </p>

</div>
</div>
<a id="ae98c19a4a03c495fdd3044c206e99afc" name="ae98c19a4a03c495fdd3044c206e99afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98c19a4a03c495fdd3044c206e99afc">&#9670;&nbsp;</a></span>trigger_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtrigger__t.html">trigger_t</a> <a class="el" href="structtrigger__t.html">trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Trigger struct representing an output, timer, action, or input. See below. </p>

</div>
</div>
<a id="a3fa7784c89589b49764048e9909d0e07" name="a3fa7784c89589b49764048e9909d0e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa7784c89589b49764048e9909d0e07">&#9670;&nbsp;</a></span>ushort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short int <a class="el" href="reactor_8h.html#a3fa7784c89589b49764048e9909d0e07">ushort</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >ushort type. Redefine here for portability if sys/types.h is not included. </p><dl class="section see"><dt>See also</dt><dd>sys/types.h</dd></dl>
<dl class="section note"><dt>Note</dt><dd>using sizeof(ushort) should be okay but not sizeof ushort. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0183c0b43037a172a1cd9aa6ed6b3822" name="a0183c0b43037a172a1cd9aa6ed6b3822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0183c0b43037a172a1cd9aa6ed6b3822">&#9670;&nbsp;</a></span>lf_spacing_policy_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="reactor_8h.html#a0183c0b43037a172a1cd9aa6ed6b3822">lf_spacing_policy_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Policy for handling scheduled events that violate the specified minimum interarrival time. The default policy is <code>defer</code>: adjust the tag to that the minimum interarrival time is satisfied. The <code>drop</code> policy simply drops events that are scheduled too early. The <code>replace</code> policy will attempt to replace the value of the event that it preceded it. Unless the preceding event has already been handled, its gets assigned the value of the new event. If the preceding event has already been popped off the event queue, the <code>defer</code> policy is fallen back to. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0183c0b43037a172a1cd9aa6ed6b3822a893b1cf0de04eaf44a009fecabd16b90" name="a0183c0b43037a172a1cd9aa6ed6b3822a893b1cf0de04eaf44a009fecabd16b90"></a>defer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0183c0b43037a172a1cd9aa6ed6b3822a1e34755950041e469ca91ff2b7d1c019" name="a0183c0b43037a172a1cd9aa6ed6b3822a1e34755950041e469ca91ff2b7d1c019"></a>drop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0183c0b43037a172a1cd9aa6ed6b3822a8a4df390c6f816287b90cb2b33ab4323" name="a0183c0b43037a172a1cd9aa6ed6b3822a8a4df390c6f816287b90cb2b33ab4323"></a>replace&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a174f339edecd4463df25e673366a2b16" name="a174f339edecd4463df25e673366a2b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174f339edecd4463df25e673366a2b16">&#9670;&nbsp;</a></span>ok_to_free_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="reactor_8h.html#a174f339edecd4463df25e673366a2b16">ok_to_free_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a174f339edecd4463df25e673366a2b16a8fe4a05f1addc1b9a4aae17d7b166646" name="a174f339edecd4463df25e673366a2b16a8fe4a05f1addc1b9a4aae17d7b166646"></a>no&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a174f339edecd4463df25e673366a2b16aad3aafaeae035f5d1c986b0b59e77458" name="a174f339edecd4463df25e673366a2b16aad3aafaeae035f5d1c986b0b59e77458"></a>token_and_value&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a174f339edecd4463df25e673366a2b16aea2a62f409bdd1a145204606c8efb75b" name="a174f339edecd4463df25e673366a2b16aea2a62f409bdd1a145204606c8efb75b"></a>token_only&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a759ba374f75ea0025b9af1bb35f14d7e" name="a759ba374f75ea0025b9af1bb35f14d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759ba374f75ea0025b9af1bb35f14d7e">&#9670;&nbsp;</a></span>port_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="reactor_8h.html#a759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Status of a given port at a given logical time.</p>
<p >If the value is 'present', it is an indicator that the port is present at the given logical time. If the value is 'absent', it is an indicator that the port is absent at the given logical time. If the value is 'unknown', it is unknown whether the port is present or absent (e.g., in a distributed application).</p>
<dl class="section note"><dt>Note</dt><dd>For non-network ports, unknown is unused. </dd>
<dd>
The absent and present fields need to be compatible with false and true respectively because for non-network ports, the status can either be present or absent (no possibility of unknown). </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a759ba374f75ea0025b9af1bb35f14d7ea1a8fae68a24a59c5629c241401fabb08" name="a759ba374f75ea0025b9af1bb35f14d7ea1a8fae68a24a59c5629c241401fabb08"></a>absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a759ba374f75ea0025b9af1bb35f14d7eaaeb73d7cb56b19bff3d9f80426ed3267" name="a759ba374f75ea0025b9af1bb35f14d7eaaeb73d7cb56b19bff3d9f80426ed3267"></a>present&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a759ba374f75ea0025b9af1bb35f14d7ea5b9f6d065e6e98483b3d3ed01f4f6cbe" name="a759ba374f75ea0025b9af1bb35f14d7ea5b9f6d065e6e98483b3d3ed01f4f6cbe"></a>unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae3c5c84c6f22c1bdf98af8b1a55a9f4b" name="ae3c5c84c6f22c1bdf98af8b1a55a9f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c5c84c6f22c1bdf98af8b1a55a9f4b">&#9670;&nbsp;</a></span>__initialize_timers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __initialize_timers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function (to be code generated) to schedule timers. </p>

</div>
</div>
<a id="a868e02a04eabb4ffed63f6141f5f64a2" name="a868e02a04eabb4ffed63f6141f5f64a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a868e02a04eabb4ffed63f6141f5f64a2">&#9670;&nbsp;</a></span>__initialize_trigger_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __initialize_trigger_objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generated function that produces a table containing all triggers (i.e., inputs, timers, and actions). </p>

</div>
</div>
<a id="a1825238bcb81ecc6aeeb6dd42d308089" name="a1825238bcb81ecc6aeeb6dd42d308089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1825238bcb81ecc6aeeb6dd42d308089">&#9670;&nbsp;</a></span>__pop_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __pop_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Pop all events from event_q with timestamp equal to current_time, extract all the reactions triggered by these events, and stick them into the reaction queue.</p>
<p >Pop all events from event_q with timestamp equal to current_tag.time, extract all the reactions triggered by these events, and stick them into the reaction queue. </p>

</div>
</div>
<a id="a1b914dafd583948c817b0ae6ce739b6d" name="a1b914dafd583948c817b0ae6ce739b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b914dafd583948c817b0ae6ce739b6d">&#9670;&nbsp;</a></span>__schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a> __schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>extra_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Internal version of the <a class="el" href="ctarget_8c.html#a961a0ed618d8dbb43f9f3b2bf3541af4">schedule()</a> function, used by generated __start_timers() function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The action or timer to be triggered. </td></tr>
    <tr><td class="paramname">delay</td><td>Offset of the event release. </td></tr>
    <tr><td class="paramname">token</td><td>The token payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error.</dd></dl>
<p>Schedule the specified trigger at current_tag.time plus the offset of the specified trigger plus the delay. See <a class="el" href="ctarget_8c.html#ab666cf351f7ca211945793b37cb29f58">schedule_token()</a> in <a class="el" href="reactor_8h.html">reactor.h</a> for details. This is the internal implementation shared by both the threaded and non-threaded versions.</p>
<p >The value is required to be either NULL or a pointer to a token wrapping the payload. The token carries a reference count, and when the reference count decrements to 0, the will be freed. Hence, it is essential that the payload be in memory allocated using malloc.</p>
<p >There are three conditions under which this function will not actually put an event on the event queue and decrement the reference count of the token (if there is one), which could result in the payload being freed. In all three cases, this function returns 0. Otherwise, it returns a handle to the scheduled trigger, which is an integer greater than 0.</p>
<p >The first condition is that a stop has been requested and the trigger offset plus the extra delay is greater than zero. The second condition is that the trigger offset plus the extra delay is greater that the requested stop time (timeout). The third condition is that the trigger argument is null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The trigger to be invoked at a later logical time. </td></tr>
    <tr><td class="paramname">extra_delay</td><td>The logical time delay, which gets added to the trigger's minimum delay, if it has one. If this number is negative, then zero is used instead. </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no new event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="aedbba6d4986cc6d46b07d53d3752270f" name="aedbba6d4986cc6d46b07d53d3752270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbba6d4986cc6d46b07d53d3752270f">&#9670;&nbsp;</a></span>__set_default_command_line_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __set_default_command_line_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generated function that optionally sets default command-line options. </p>

</div>
</div>
<a id="af8aacf433fcf349ffa1b163962eb3681" name="af8aacf433fcf349ffa1b163962eb3681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8aacf433fcf349ffa1b163962eb3681">&#9670;&nbsp;</a></span>__start_time_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __start_time_step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Generated function that resets outputs to be absent at the start of a new time step.</p>
<p >Use tables to reset is_present fields to false, set intended_tag fields in federated execution to the current_tag, and decrement reference counts between time steps and at the end of execution. </p>

</div>
</div>
<a id="a9ea1110b1a18ccf10931bf5f9adaf299" name="a9ea1110b1a18ccf10931bf5f9adaf299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea1110b1a18ccf10931bf5f9adaf299">&#9670;&nbsp;</a></span>__trigger_shutdown_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool __trigger_shutdown_reactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function (to be code generated) to trigger shutdown reactions. </p>

</div>
</div>
<a id="a1d807ba211ee2edb588750d4553090c1" name="a1d807ba211ee2edb588750d4553090c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d807ba211ee2edb588750d4553090c1">&#9670;&nbsp;</a></span>__trigger_startup_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __trigger_startup_reactions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function (to be code generated) to trigger startup reactions. </p>

</div>
</div>
<a id="abadead0c4f54963b062503cf6cb7ace7" name="abadead0c4f54963b062503cf6cb7ace7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadead0c4f54963b062503cf6cb7ace7">&#9670;&nbsp;</a></span>_lf_advance_logical_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_advance_logical_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td>
          <td class="paramname"><em>next_time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Advance from the current tag to the next. If the given next_time is equal to the current time, then increase the microstep. Otherwise, update the current time and set the microstep to zero.</p>
<p >Advance from the current tag to the next. If the given next_time is equal to the current time, then increase the microstep. Otherwise, update the current time and set the microstep to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_time</td><td>The time step to advance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46845578328233d51b6bfb55e8724ee1" name="a46845578328233d51b6bfb55e8724ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46845578328233d51b6bfb55e8724ee1">&#9670;&nbsp;</a></span>_lf_create_dummy_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent__t.html">event_t</a> * _lf_create_dummy_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a>&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td>
          <td class="paramname"><em>next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a dummy event to be used as a spacer in the event queue. </p>

</div>
</div>
<a id="a60ec02f52c1a7db4c7bdbc2871eae636" name="a60ec02f52c1a7db4c7bdbc2871eae636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ec02f52c1a7db4c7bdbc2871eae636">&#9670;&nbsp;</a></span>_lf_fd_send_stop_request_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_fd_send_stop_request_to_rti </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >For a federated execution, send a STOP_REQUEST message to the RTI.</p>
<p >Send a MSG_TYPE_STOP_REQUEST message to the RTI with payload equal to the current tag plus one microstep.</p>
<p >This function raises a global barrier on logical tag at the current tag.</p>
<p >This function assumes the caller holds the mutex lock. </p>

</div>
</div>
<a id="aeaa7db644ec69c067d3d6aadd2da9d81" name="aeaa7db644ec69c067d3d6aadd2da9d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa7db644ec69c067d3d6aadd2da9d81">&#9670;&nbsp;</a></span>_lf_get_new_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent__t.html">event_t</a> * _lf_get_new_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get a new event. If there is a recycled event available, use that. If not, allocate a new one. In either case, all fields will be zero'ed out. </p>

</div>
</div>
<a id="ab461661c6c9757862959540fe57e3554" name="ab461661c6c9757862959540fe57e3554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab461661c6c9757862959540fe57e3554">&#9670;&nbsp;</a></span>_lf_is_blocked_by_executing_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lf_is_blocked_by_executing_reaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If multithreaded and the reaction is blocked by a currently executing reaction, return true. Otherwise, return false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>The reaction.</td></tr>
  </table>
  </dd>
</dl>
<p>Return false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>The reaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa46a83ed702e2c83d42625a8c78a9f50" name="aa46a83ed702e2c83d42625a8c78a9f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46a83ed702e2c83d42625a8c78a9f50">&#9670;&nbsp;</a></span>_lf_notify_workers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_notify_workers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If multithreaded, notify workers that something has changed on the reaction_q. Otherwise, do nothing.</p>
<p >Do nothing. This implementation is not multithreaded.</p>
<p >Notify workers that something has changed on the reaction_q. Notification is performed only if there is a reaction on the reaction queue that is ready to execute and there is an idle worker thread. This function acquires the mutex lock. </p>

</div>
</div>
<a id="a662cfd5714e5930f5e1c880f13deba6d" name="a662cfd5714e5930f5e1c880f13deba6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662cfd5714e5930f5e1c880f13deba6d">&#9670;&nbsp;</a></span>_lf_recycle_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_recycle_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Recycle the given event. Zero it out and pushed it onto the recycle queue. </p>

</div>
</div>
<a id="af1f3a3c4613102e28fc0105408731c5e" name="af1f3a3c4613102e28fc0105408731c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f3a3c4613102e28fc0105408731c5e">&#9670;&nbsp;</a></span>_lf_schedule_at_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_schedule_at_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *&#160;</td>
          <td class="paramname"><em>trigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Schedule events at a specific tag (time, microstep), provided that the tag is in the future relative to the current tag. The input time values are absolute.</p>
<p >If there is an event found at the requested tag, the payload is replaced and 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The trigger to be invoked at a later logical time. </td></tr>
    <tr><td class="paramname">tag</td><td>Logical tag of the event </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 if no new event was scheduled (instead, the payload was updated), or -1 for error.</dd></dl>
<p>Schedule events at a specific tag (time, microstep), provided that the tag is in the future relative to the current tag. The input time values are absolute.</p>
<p >If there is an event found at the requested tag, the payload is replaced and 0 is returned.</p>
<p >Note that this function is an internal API that must be called with tags that are in order for a given trigger. This means that the following order is illegal: _lf_schedule_at_tag(trigger1, bigger_tag, ...); _lf_schedule_at_tag(trigger1, smaller_tag, ...); where bigger_tag &gt; smaller_tag. This function is primarily used for network communication (which is assumed to be in order).</p>
<p >This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>The trigger to be invoked at a later logical time. </td></tr>
    <tr><td class="paramname">tag</td><td>Logical tag of the event </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for success, 0 if no new event was scheduled (instead, the payload was updated), or -1 for error (the tag is equal to or less than the current tag). </dd></dl>

</div>
</div>
<a id="a340e25ab993a3fe9e402534cc073f0e8" name="a340e25ab993a3fe9e402534cc073f0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340e25ab993a3fe9e402534cc073f0e8">&#9670;&nbsp;</a></span>_lf_schedule_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a> _lf_schedule_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Schedule an action to occur with the specified value and time offset with a copy of the specified value. If the value is non-null, then it will be copied into newly allocated memory under the assumption that its size is given in the trigger's token object's element_size field multiplied by the specified length. See <a class="el" href="reactor_8c.html#a369700b5e0906335f3d304a67eec5f29">_lf_schedule_token()</a>, which this uses, for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>Pointer to an action on a self struct. </td></tr>
    <tr><td class="paramname">offset</td><td>The time offset over and above that in the action. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value to copy. </td></tr>
    <tr><td class="paramname">length</td><td>The length, if an array, 1 if a scalar, and 0 if value is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error.</dd></dl>
<p>Schedule an action to occur with the specified value and time offset with a copy of the specified value. See <a class="el" href="reactor_8h.html">reactor.h</a> for documentation. </p>

</div>
</div>
<a id="aa715873b79dee5b9f50daa2fef88cf34" name="aa715873b79dee5b9f50daa2fef88cf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa715873b79dee5b9f50daa2fef88cf34">&#9670;&nbsp;</a></span>_lf_schedule_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a> _lf_schedule_int </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>extra_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Schedule the specified action with an integer value at a later logical time that depends on whether the action is logical or physical and what its parameter values are. This wraps a copy of the integer value in a token. See <a class="el" href="ctarget_8c.html#ab666cf351f7ca211945793b37cb29f58">schedule_token()</a> for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered. </td></tr>
    <tr><td class="paramname">extra_delay</td><td>Extra offset of the event release above that in the action. </td></tr>
    <tr><td class="paramname">value</td><td>The value to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error.</dd></dl>
<p>Variant of schedule_value when the value is an integer. See <a class="el" href="reactor_8h.html">reactor.h</a> for documentation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>Pointer to an action on the self struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a369700b5e0906335f3d304a67eec5f29" name="a369700b5e0906335f3d304a67eec5f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369700b5e0906335f3d304a67eec5f29">&#9670;&nbsp;</a></span>_lf_schedule_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a> _lf_schedule_token </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>extra_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Schedule the specified action with the specified token as a payload. This will trigger an event at a later logical time that depends on whether the action is logical or physical and what its parameter values are.</p>
<p >logical action: A logical action has an offset (default is zero) and a minimum interarrival time (MIT), which also defaults to zero. The logical time at which this scheduled event will trigger is the current time plus the offset plus the delay argument given to this function. If, however, that time is not greater than a prior triggering of this logical action by at least the MIT, then the one of two things can happen depending on the policy specified for the action. If the action's policy is DROP (default), then the action is simply dropped and the memory pointed to by value argument is freed. If the policy is DEFER, then the time will be increased to equal the time of the most recent triggering plus the MIT.</p>
<p >For the above, "current time" means the logical time of the reaction that is calling this function. Logical actions should always be scheduled within a reaction invocation, never asynchronously from the outside. FIXME: This needs to be checked.</p>
<p >physical action: A physical action has all the same parameters as a logical action, but its timestamp will be the larger of the current physical time and the time it would be assigned if it were a logical action.</p>
<p >The token is required to be either NULL or a pointer to a token created using <a class="el" href="reactor_8h.html#a0b3e914b48f5f90533eecbf63acdf8d9">create_token()</a>.</p>
<p >There are three conditions under which this function will not actually put an event on the event queue and decrement the reference count of the token (if there is one), which could result in the payload being freed. In all three cases, this function returns 0. Otherwise, it returns a handle to the scheduled trigger, which is an integer greater than 0.</p>
<p >The first condition is that stop() has been called and the time offset of this event is greater than zero. The second condition is that the logical time of the event is greater that the stop time (timeout) that is specified in the target properties or on the command line. The third condition is that the trigger argument is null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered. </td></tr>
    <tr><td class="paramname">extra_delay</td><td>Extra offset of the event release above that in the action. </td></tr>
    <tr><td class="paramname">token</td><td>The token to carry the payload or null for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error.</dd></dl>
<p>Schedule the specified trigger at current_tag.time plus the offset of the specified trigger plus the delay. See <a class="el" href="reactor_8h.html">reactor.h</a> for documentation. </p>

</div>
</div>
<a id="a5e5591f2a5684d3b9ef713668e1937be" name="a5e5591f2a5684d3b9ef713668e1937be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5591f2a5684d3b9ef713668e1937be">&#9670;&nbsp;</a></span>_lf_schedule_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="reactor_8h.html#a5ad7d32f3a1ddabdc2933223ca6ce2ea">handle_t</a> _lf_schedule_value </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>extra_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Variant of schedule_token that creates a token to carry the specified value. The value is required to be malloc'd memory with a size equal to the element_size of the specifies action times the length parameter. See <a class="el" href="reactor_8c.html#a369700b5e0906335f3d304a67eec5f29">_lf_schedule_token()</a> for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered. </td></tr>
    <tr><td class="paramname">extra_delay</td><td>Extra offset of the event release above that in the action. </td></tr>
    <tr><td class="paramname">value</td><td>Dynamically allocated memory containing the value to send. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, if it is an array, or 1 for a scalar and 0 for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error.</dd></dl>
<p>Variant of schedule_token that creates a token to carry the specified value. See <a class="el" href="reactor_8h.html">reactor.h</a> for documentation. </p>

</div>
</div>
<a id="a0b3e914b48f5f90533eecbf63acdf8d9" name="a0b3e914b48f5f90533eecbf63acdf8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3e914b48f5f90533eecbf63acdf8d9">&#9670;&nbsp;</a></span>create_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * create_token </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new token and initialize it. The value pointer will be NULL and the length will be 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>The size of an element carried in the payload or 0 if there is no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new or recycled <a class="el" href="structlf__token__t.html">lf_token_t</a> struct.</dd></dl>
<p>Create a new token and initialize it. The value pointer will be NULL and the length will be 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_size</td><td>The size of an element carried in the payload or 0 if there is no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or recycled <a class="el" href="structlf__token__t.html">lf_token_t</a> struct.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For multithreaded applications, the caller must hold the mutex lock because it accesses global variables. </dd></dl>

</div>
</div>
<a id="a8b4f2e4e87e43670217c0c53099ae2f5" name="a8b4f2e4e87e43670217c0c53099ae2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f2e4e87e43670217c0c53099ae2f5">&#9670;&nbsp;</a></span>get_start_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#a0c4810f46596400a763cfe99b3cfa7b1">instant_t</a> get_start_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the time of the start of execution in nanoseconds. This is both the starting physical and starting logical time. On many platforms, this is the number of nanoseconds since January 1, 1970, but it is actually platform dependent. </p><dl class="section return"><dt>Returns</dt><dd>A time instant.</dd></dl>
<p>Return the physical time of the start of execution in nanoseconds. * On many platforms, this is the number of nanoseconds since January 1, 1970, but it is actually platform dependent. * </p><dl class="section return"><dt>Returns</dt><dd>A time instant. </dd></dl>

</div>
</div>
<a id="a54be08fbc7990c2d8082a31cbbf6e019" name="a54be08fbc7990c2d8082a31cbbf6e019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54be08fbc7990c2d8082a31cbbf6e019">&#9670;&nbsp;</a></span>get_stp_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> get_stp_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return the global STP offset on advancement of logical time for federated execution. </p>

</div>
</div>
<a id="ad96dc6cbe1d3365e52aad6aecbf036d8" name="ad96dc6cbe1d3365e52aad6aecbf036d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96dc6cbe1d3365e52aad6aecbf036d8">&#9670;&nbsp;</a></span>print_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_snapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Print a snapshot of the priority queues used during execution (for debugging).</p>
<p >If DEBUG logging is enabled, prints the status of the event queue, the reaction queue, and the executing queue. </p>

</div>
</div>
<a id="af629769c213699f0e4c9360811ee7251" name="af629769c213699f0e4c9360811ee7251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af629769c213699f0e4c9360811ee7251">&#9670;&nbsp;</a></span>request_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void request_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Request a stop to execution as soon as possible. In a non-federated execution, this will occur at the conclusion of the current logical time. In a federated execution, it will likely occur at a later logical time determined by the RTI so that all federates stop at the same logical time.</p>
<p >Stop execution at the conclusion of the next microstep. </p>

</div>
</div>
<a id="a75a5bf324229d35fb88541a04449c95b" name="a75a5bf324229d35fb88541a04449c95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a5bf324229d35fb88541a04449c95b">&#9670;&nbsp;</a></span>set_stp_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_stp_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set the global STP offset on advancement of logical time for federated execution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>A positive time value to be applied as the STP offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a114c79dc673219d5df3b794552ca88d7" name="a114c79dc673219d5df3b794552ca88d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114c79dc673219d5df3b794552ca88d7">&#9670;&nbsp;</a></span>terminate_execution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void terminate_execution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function (to be code generated) to terminate execution. This will be invoked after all shutdown actions have completed.</p>
<p >Close sockets used to communicate with other federates, if they are open, and send a MSG_TYPE_RESIGN message to the RTI. This implements the function defined in <a class="el" href="reactor_8h.html">reactor.h</a>. For unfederated execution, the code generator generates an empty implementation. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a39f588e1df453139dbb9a4157dda2027" name="a39f588e1df453139dbb9a4157dda2027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f588e1df453139dbb9a4157dda2027">&#9670;&nbsp;</a></span>_lf_global_time_STP_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="platform_8h.html#a25b148cb4bef9a108b00306879433f7b">interval_t</a> _lf_global_time_STP_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Global STP offset uniformly applied to advancement of each time step in federated execution. This can be retrieved in user code by calling <a class="el" href="reactor_8h.html#a54be08fbc7990c2d8082a31cbbf6e019">get_stp_offset()</a> and adjusted by calling <a class="el" href="reactor_8h.html#a75a5bf324229d35fb88541a04449c95b">set_stp_offset(interval_t offset)</a>. </p>

</div>
</div>
<a id="af74a2782bda0d66298d22d637ad964b5" name="af74a2782bda0d66298d22d637ad964b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74a2782bda0d66298d22d637ad964b5">&#9670;&nbsp;</a></span>_lf_number_of_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int _lf_number_of_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >The number of worker threads for threaded execution. By default, execution is not threaded and this variable will have value 0, meaning that the execution is not threaded. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
